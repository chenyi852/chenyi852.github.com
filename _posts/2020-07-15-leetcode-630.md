---
layout: post  
title: "leetcode-630"  
subtitle: '课程表 III'  
author: "Johnny"  
header-style: text  
tags:
  - leetcode
  - 课程表 III
---

[[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]
第一个元素时t（上课时间），第二个元素是d（关闭时间）
思路：
贪心算法
1 按照d单调递增对二位数组排序
2 每次循环，t_sum + t < d 
3 如果是，将t累加到t_sum, 把t push到优先级队列（优先级队列按照t递增排序，栈顶是最大值）
4 如果非，则判断t < 优先级队列栈顶
5 如果是，则将栈顶弹出，将t push到优先级队列，t_sum += t;
6 循环遍历完成后，返回栈顶元素个数


这种方案有问题，为了实现优先级队列，每次插入元素会排序，当元素

```
#define N_QUEUE 10001
//#define pr_log(fmt,...) printf("[%s|%d]"fmt, __func__, __LINE__, ##__VA_ARGS__)
#define pr_log
typedef struct _pri_q_t {
    int top;
    int data[N_QUEUE];
}pri_q_t;

static pri_q_t q;
static void q_init(void)
{
    q.top = 0;
}

static int com_q(const void *a, const void *b)
{
    return (*(int *)a - *(int *)b);
}

static void q_push(int d) 
{
    pr_log("%d\n", d);
    q.data[q.top++] = d;

    qsort(q.data, q.top, sizeof(int), com_q);
}

static int q_pop(void)
{    
    pr_log("%d\n", q.data[q.top - 1]);
    return q.data[--q.top];
}

static int q_top(void)
{
    return q.data[q.top - 1];
}

static int q_count(void)
{
    return q.top;
}

static int q_empty(void) 
{
    return (q.top == 0);
}

static int compare(const void *a, const void *b)
{
    int *ap = *(int **)a;
    int *bp = *(int **)b;
    int ans = 0;
    
    ans = (ap[1] - bp[1]);
    if (ans == 0) {
        ans = ap[1] - bp[1];
    }

    return ans;
}

int scheduleCourse(int** courses, int coursesSize, int* coursesColSize){
    int t_sum = 0;
    int d_max = 0;

 
    qsort(courses, coursesSize, sizeof(courses[0]), compare);
    
    q_init();

    for (int i = 0; i < coursesSize; i++) {
        int t = courses[i][0];
        int d = courses[i][1];
        int top;
 
        if (t_sum + t <= d) {
            t_sum += t;
            q_push(t);
        } else if (!q_empty() && t < q_top()){
            top = q_pop();
            t_sum -= top;
            q_push(t);
            t_sum += t;
        }
    }
    return q_count();
} return ans;
}
```
